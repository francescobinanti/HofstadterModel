import numpy as np
import scipy as sp
import sys
import argparse
import time
import math
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import matplotlib as mpl
from scipy.fft import fft, fftfreq
import GenericModule as gm
    
# System parameters
J = 1.
U = 0.
U3 = 0.
FluxDensity = 0.2
trapConf = 0.

# Handle the parameters parsed by the command line
parser = argparse.ArgumentParser()
parser.add_argument('-N', type=int, help='number of particles')
parser.add_argument('-L', type=int, help='side of the square lattice of size LxL')
parser.add_argument('-J', type=float, help='tunneling energy')
parser.add_argument('-U', type=float, help='two-body onsite interaction (only in softcore mode)')
parser.add_argument('-U3', type=float, help='three-body onsite interaction (only in softcore mode)')
parser.add_argument('-r0', type=float, help='Laguerre-Gauss radius parameter (for a pure gaussian beam it is the gaussian dispersion)')
parser.add_argument('--omega', type=float, help='Laguerre-Gauss beam frequency')
parser.add_argument('--conf', type=float, help='harmonic trap confinement strength (v0) as v0 * r^2')
parser.add_argument('--gamma', type=float, default=2, help='trap steepness (g) as v0 * (r)^g (default=2)')
parser.add_argument('--alpha', type=float, help='magnetic flux density as alpha=p/q')
parser.add_argument('--hardcore', type=int, nargs='?', const=1, default=0, help='hardcore bosons mode')
# Plotting parameters
parser.add_argument('--spectrumflux', type=int, nargs='?', const=1, default=0, help='plot the energy spectrum E vs the magnetic flux density alpha (need to speficy --alphainit and --alphafinal)')
parser.add_argument('--alphainit', type=float, default=0.01, help='initial value of the flux alpha for the energy plot E vs alpha')
parser.add_argument('--alphafinal', type=float, default=0.1, help='final value of the flux alpha for the energy plot E vs alpha')
parser.add_argument('--alphastep', type=float, default=0.01, help='step for the increase of alpha in the E vs alpha plot (default=0.01)')
parser.add_argument('--c4spectrum', type=int, nargs='?', const=1, default=0, help='plot the energy spectrum E vs C4 quantum numbers')
parser.add_argument('--density', type=int, help='plot the local density of |psi_n> on the square lattice (provide n as parameter)')
parser.add_argument('--densitydiagonal', type=int, nargs='?', const=1, default=0, help='add to the --density flag in order to plot the density along the diagonal cut of the lattice (passing through the center)')
parser.add_argument('--densityvertical', type=int, nargs='?', const=1, default=0, help='add to the --density flag in order to plot the density along the vertical cut of the lattice (passing through the center)')
parser.add_argument('--densitygscomparison', type=int, nargs='?', const=1, default=0, help='to plot the corresponding vertical or diagonal ground state density on the same plot with a possible excited state density')
parser.add_argument('--densityfft', type=int, nargs='?', const=1, default=0, help='if specified, plot the discrete Fourier transform on the density along the vertical or diagonal cut')
parser.add_argument('--absorption', type=int, nargs='?', const=1, default=0, help='plot the absorption spectrum from data file generated by LaguerreGaussAbsorption.py')
parser.add_argument('--sety', type=float, default=0, help='to specify the maximum value of the y axis for the absorption spectrum (default=automatic)')
parser.add_argument('--corrfuncalpha', type=int, default=0, help='take integer n=2,3 and plot the n-point correlation function vs alpha (need to speficy --alphainit and --alphafinal)')
# Time evolution parameters
parser.add_argument('--excfraction', type=int, nargs='?', const=1, default=0, help='plot the excitation fraction after time evolution with the LG beam (need to specify the time evolution parameters, i.e. --winit, --wfinal, --wstep, --epsilon and --angmom)')
parser.add_argument('--winit', type=float, default=0.01, help='inital value of the laser frequency')
parser.add_argument('--wfinal', type=float, default=0.5, help='final value of the laser frequency')
parser.add_argument('--wstep', type=float, default=0.01, help='step for the increase of the laser frequency from --winit to --wfinal (default=0.01)')
parser.add_argument('--angmom', type=int, default=-1, help='angular momentum injected by the laser (default=-1)')
parser.add_argument('--epsilon', type=float, default=0.05, help='strength of the LG perturbation')
parser.add_argument('--densityevolution', type=int, nargs='?', const=1, default=0, help='plot the density evolution in time with respect to the ground state density, both at the edge and in the bulk (these regions are defined in the time evolution code). Need to specify the laser parameters.')
parser.add_argument('--multifreqdenevol', type=int, nargs='?', const=1, default=0, help='flag to enable the --densityevolution plot for multiple frequencies (--winit and --wfinal to be specified then)')
parser.add_argument('--densityhisto', type=int, nargs='?', const=1, default=0, help='plot the density variation at a given time --tdensity vs the frequency of the laser (so you need to specify --winit and --wfinal to span the frequencies)')
parser.add_argument('--tdensity', type=float, default=20.0, help='time at which we have to extract the density vs frequency data (default=20.0)')
parser.add_argument('--bulkprobe', type=int, nargs='?', const=1, default=0, help='flag that turns that makes the plot of the density vs frequency act in the bulk instead of the edge')
parser.add_argument('--protocolresult', type=int, nargs='?', const=1, default=0, help='Plot an absorption spectrum with the resonance points generated by the time evolution protocol on top of it (need to specify the parameters of the laser). It uses the file of maximum values of the density variation created via --densityhisto')
parser.add_argument('--savemaxdensity', type=int, nargs='?', const=1, default=0, help='flag to save on a file the resonance energies related to the peaks of the density variation histogram')
# Side options
parser.add_argument('--gammasplit', type=int, nargs='?', const=1, default=0, help='calculate the energy splitting of states in sector --angmom vs trap steepness (from gamma=2 to gamma=--gammafinal)')
parser.add_argument('--gammafinal', type=float, default=2.1, help='final value of gamma used in the option --gammasplit')
parser.add_argument('--sizesplit', type=int, nargs='?', const=1, default=0, help='calculate the energy splitting of states in the sector l=-2 vs system size LxL (from L=10 to L=6)')
args = parser.parse_args()

if args.N is not None: N = args.N
if args.L is not None: L = args.L
if args.J is not None: J = args.J
if args.U is not None: U3 = args.U
if args.U3 is not None: U3 = args.U3
if args.alpha is not None: FluxDensity = args.alpha
if args.conf is not None: trapConf = args.conf
if args.r0 is not None: r0 = args.r0
if args.omega is not None: omega = args.omega

gamma = args.gamma
gammaFinal = args.gammafinal

if args.hardcore == 0:
    hardcore = False
elif args.hardcore == 1:
    hardcore = True
    
if args.spectrumflux == 0:
    spectrumFlux = False
elif args.spectrumflux == 1:
    spectrumFlux = True
    
if args.c4spectrum == 0:
    c4Spectrum = False
elif args.c4spectrum == 1:
    c4Spectrum = True
    
alphaInit = args.alphainit
alphaFinal = args.alphafinal
alphaStep = args.alphastep

corrFuncOrder = args.corrfuncalpha

if args.excfraction == 0:
    excFrac = False
elif args.excfraction == 1:
    excFrac = True
wInit = args.winit
wFinal = args.wfinal
wStep = args.wstep
angMom = args.angmom
eps = args.epsilon

if args.densityevolution == 0:
    densityEvolution = False
elif args.densityevolution == 1:
    densityEvolution = True
    
if args.bulkprobe == 0:
    bulkProbeFlag = False
elif args.bulkprobe == 1:
    bulkProbeFlag = True
    
if args.protocolresult == 0:
    protocolResults = False
elif args.protocolresult == 1:
    protocolResults = True

Ns = L*L

# Enable LaTeX rendering
plt.rcParams['text.usetex'] = True
plt.rcParams['font.size'] = 30
plt.rcParams['savefig.bbox'] = 'tight'
plt.rcParams['xtick.direction'] = 'in'
plt.rcParams['ytick.direction'] = 'in'

if (spectrumFlux == True):
    for a in np.arange(alphaInit, alphaFinal+alphaStep, alphaStep):
        fileName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=round(a,2), N=N, spectrum=True)
        energies = gm.LoadSpectrum(fileName)
        
        plt.xlabel(r'$\alpha$')
        plt.ylabel(r'$E-E_0$')
        plt.scatter(np.full(len(energies), a), energies-energies[0], marker='o', s=1.5, facecolors='#0066cc')
    plt.savefig(fileName+'_plot.pdf')
    
if (c4Spectrum == True):
    fileName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, spectrum=True, c4=True)
    data = gm.LoadC4Spectrum(fileName)
    
    fig, ax = plt.subplots()
    gsEnergy = np.min(data[1])
    
    for i in np.arange(0,len(data[0])):
        rect = patches.Rectangle((data[0][i] - 0.125, (data[1][i]-gsEnergy)), width=0.25, height=0.003, facecolor='blue')
        ax.add_patch(rect)
            
    ax.set_xlim(min(data[0]) - 0.5, max(data[0]) + 0.5)
    ax.set_ylim(min(data[1]) - gsEnergy - 0.1, max(data[1]) - gsEnergy + 0.1)
    
    ax.set_xticks([0,1,2,3])
    
    plt.xlabel(r'$L_4$')
    plt.ylabel(r'$E-E_0$')
    
    plt.savefig(fileName+'_plot.pdf')
    
if args.density is not None:
    selEigenstateDen = args.density
    fileName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, selEigenstateDen, U3=U3, alpha=FluxDensity, N=N, localDensity=True)
    x, y, density = gm.LoadDensity(fileName)
    x = x.astype(int)
    y = y.astype(int)
    densityArray = np.zeros((L,L))
    densityArray[x,y] = density
    plt.imshow(densityArray, cmap='inferno', extent=[-0.5, L - 0.5, -0.5, L - 0.5])
    plt.colorbar(label=r'$\left < \hat n_{xy} \right >$')
    plt.xlabel(r'$x$')
    plt.ylabel(r'$y$')
    plt.xticks(np.arange(L), np.arange(L))
    plt.yticks(np.arange(L), np.arange(L))
    plt.savefig(fileName+'.pdf', format='pdf')
    plt.close()
    
    if args.densitydiagonal == 1:
        plt.figure()
        xAxis = np.arange(0,L)
        diagDensity = [densityArray[i,(L-1)-i] for i in np.arange(0,L)]
        plt.xticks(np.arange(0,L,1))
        plt.ylabel(r'$\left < \hat n_{xy} \right >_{diag}$')
        plt.xlabel(r'$(x,y)_{diag}$')
        plt.scatter(xAxis, diagDensity, marker='o', s=1.5, facecolors='#0066cc')
        plt.plot(xAxis, diagDensity, color='#0066cc', linewidth=0.7)
        
        if args.densitygscomparison == 1:
            fileNameGS = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, nEigenstate=0, U3=U3, alpha=FluxDensity, N=N, localDensity=True)
            x, y, gsDensity = gm.LoadDensity(fileNameGS)
            x = x.astype(int)
            y = y.astype(int)
            gsDensityArray = np.zeros((L,L))
            gsDensityArray[x,y] = gsDensity
            gsDiagDensity = [gsDensityArray[i,(L-1)-i] for i in np.arange(0,L)]
            plt.scatter(xAxis, gsDiagDensity, marker='o', s=1.5, facecolors='g')
            plt.plot(xAxis, gsDiagDensity, color='g', linewidth=0.7, label='$GS$')
            plt.scatter(xAxis, np.array(diagDensity)-np.array(gsDiagDensity), marker='o', s=1.5, facecolors='orange')
            plt.plot(xAxis, np.array(diagDensity)-np.array(gsDiagDensity), color='orange', linewidth=0.7, label=r'$\left < \hat n_{xy} \right > - GS$')
            plt.legend()
                
        plt.text(0.05, 0.85, f'$\l={{{angMom}}}$', transform=plt.gca().transAxes)
        plt.savefig(fileName+f'_diagonal_l_{angMom}.pdf', format='pdf')
        plt.close()
        
        # Fourier transform (only for diagonal cut so far)
        if args.densityfft == 1:
            plt.figure()
            diagDensityFFT = np.fft.fft(diagDensity)
            freqs = np.fft.fftfreq(L)
            freqs = np.fft.fftshift(freqs)
            plt.scatter(freqs, np.abs(diagDensityFFT), marker='o', s=1.5, facecolors='#0066cc')
            plt.plot(freqs, np.abs(diagDensityFFT), color='#0066cc', linewidth=0.7)
            plt.ylabel(r'$\left < \hat n_{k} \right >_{diagonal}$')
            plt.xlabel(r'$k_{diagonal}$')
            plt.savefig(fileName+f'_diagonalFFT_l_{angMom}.pdf', format='pdf')
            plt.close()
        
    if args.densityvertical == 1:
        plt.figure()
        xAxis = np.arange(0,L)
        center = int(gm.FindCenter(L))
        vertDensity = [densityArray[center,i] for i in np.arange(0,L)]
        plt.xticks(np.arange(0,L,1))
        plt.ylabel(r'$\left < \hat n_{xy} \right >_{vert}$')
        plt.xlabel(r'$(x,y)_{vert}$')
        plt.scatter(xAxis, vertDensity, marker='o', s=1.5, facecolors='#0066cc')
        plt.plot(xAxis, vertDensity, color='#0066cc', linewidth=0.7)
        
        if args.densitygscomparison == 1:
            fileNameGS = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, nEigenstate=0, U3=U3, alpha=FluxDensity, N=N, localDensity=True)
            x, y, gsDensity = gm.LoadDensity(fileNameGS)
            x = x.astype(int)
            y = y.astype(int)
            gsDensityArray = np.zeros((L,L))
            gsDensityArray[x,y] = gsDensity
            gsVertDensity = [gsDensityArray[center,i] for i in np.arange(0,L)]
            plt.scatter(xAxis, gsVertDensity, marker='o', s=1.5, facecolors='g')
            plt.plot(xAxis, gsVertDensity, color='g', linewidth=0.7, label='$GS$')
            plt.scatter(xAxis, np.array(vertDensity)-np.array(gsVertDensity), marker='o', s=1.5, facecolors='orange')
            plt.plot(xAxis, np.array(vertDensity)-np.array(gsVertDensity), color='orange', linewidth=0.7, label=r'$\left < \hat n_{xy} \right >-GS$')
            plt.legend()
            
        plt.savefig(fileName+f'_vertical_l_{angMom}.pdf', format='pdf')
        plt.close()
    
if args.absorption == 1:
    fig, ax = plt.subplots()
    cmap = mpl.colormaps['ocean_r']
    sm = mpl.cm.ScalarMappable(cmap=cmap, norm=plt.Normalize(vmin=0.0, vmax=0.7))
    #norm = mpl.colors.Normalize(vmin=0.0, vmax=1.0)
    
    # l < 0 region
    fileName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, absSpectrum=True, r0=args.r0)
    energy, l, matElem = gm.LoadFileThree(fileName+'_neg')
    
    matElem[matElem < 1e-5] = np.NaN
    
    sm.set_array(matElem)
    colors = sm.to_rgba(matElem)
    
    for i in np.arange(0,len(energy)):
        rect = patches.Rectangle((l[i] - 0.45, energy[i]), width=0.9, height=0.003, color=colors[i])
        ax.set_facecolor(cmap(0))
        ax.add_patch(rect)
        
    # l > 0 region
    fileName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, absSpectrum=True, r0=args.r0)
    energy, l, matElem = gm.LoadFileThree(fileName+'_pos')
    
    matElem[matElem < 1e-5] = np.NaN
    
    sm.set_array(matElem)
    colors = sm.to_rgba(matElem)
    
    for i in np.arange(0,len(energy)):
        rect = patches.Rectangle((l[i] - 0.45, energy[i]), width=0.9, height=0.003, color=colors[i])
        ax.set_facecolor(cmap(0))
        ax.add_patch(rect)

    ax.set_xlim(-max(l) - 0.5, max(l) + 0.5)
    if args.sety == 0:
        ax.set_ylim(min(energy) - 0.1, max(energy) + 0.1)
    else:
        ax.set_ylim(min(energy) - 0.1, args.sety)
    
    plt.xticks(np.arange(-max(l),max(l)+1, 2))
    
    cbar = plt.colorbar(sm)
    cbar.set_label(r'$|I_n|^2$')
    plt.xlabel(r'$l$')
    plt.ylabel(r'$\omega_n$')
    
    plt.savefig(fileName+'.pdf')
    
if corrFuncOrder != 0:
    fileName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=round(alphaInit,2), N=N, corrFunction=corrFuncOrder)
    alpha, cFunction = gm.LoadFileTwo(fileName)
    
    if corrFuncOrder == 2:
        plt.xlabel(r'$\alpha$')
        plt.ylabel(r'$C^{(2)}$')
        plt.scatter(alpha, cFunction, marker='o', s=1.5, facecolors='#0066cc')
        plt.plot(alpha, cFunction, color='#0066cc', linewidth=0.7)
        plt.savefig(fileName+'.pdf')
    
    elif corrFuncOrder == 3:
        plt.xlabel(r'$\alpha$')
        plt.ylabel(r'$10^2 C^{(3)}$')
        plt.scatter(alpha, 1e+2 * cFunction, marker='o', s=1.5, facecolors='#0066cc')
        plt.plot(alpha, 1e+2 * cFunction, color='#0066cc', linewidth=0.7)
        plt.savefig(fileName+'.pdf')
        
if excFrac == True:
    legend = []
    colors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999', '#66c2a5']
    c = 0

    for w in np.arange(wInit, wFinal, wStep):
        fileName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, excFrac=True, timeEvolAngMom=angMom, timeEvolEps=eps, timeEvolOmega=round(w,2), r0=r0)
        t, excFracData = gm.LoadFileTwo(fileName)
        
        plt.xlabel(r'$t$')
        plt.ylabel(r'$N_{l,\omega}(t)$')
        plt.scatter(t, excFracData, marker='o', s=1.5, facecolors=colors[c])
        legend.append(f'$\omega={{{round(w,2)}}}$')
        
        plotName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, excFrac=True)
        
        plt.legend(legend)
        plt.savefig(plotName+'.pdf')
        
        c = c + 1
        
if densityEvolution == True:
    if args.multifreqdenevol == 0:
        fileName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, densityEvolution=True, r0=r0, timeEvolAngMom=angMom, timeEvolEps=eps, timeEvolOmega=omega)
        t, edgeDensity = gm.LoadFileTwo(fileName + '_edge')
        t, bulkDensity = gm.LoadFileTwo(fileName + '_bulk')
        
        plt.xlabel(r'$t$')
        plt.scatter(t, edgeDensity, marker='o', s=1.5, facecolors='g')
        plt.scatter(t, bulkDensity, marker='o', s=1.5, facecolors='orange')
        plt.text(0.05, 0.05, f'$\omega={{{omega}}}$', transform=plt.gca().transAxes, fontsize=12)
        plt.text(0.05, 0.1, f'$l={{{angMom}}}$', transform=plt.gca().transAxes, fontsize=12)
        
        plt.legend([r'$\Delta\rho_{edge}$',r'$\Delta\rho_{bulk}$'])
        
        plotName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, densityEvolution=True, r0=r0, timeEvolAngMom=angMom, timeEvolEps=eps, timeEvolOmega=omega)
        plt.savefig(plotName+'.pdf')
        plt.close()
    
    if args.multifreqdenevol == 1:
        colors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999', '#66c2a5']
        c = 0
        plt.figure()
        plt.xlabel(r'$t$')
        for w in np.arange(wInit, wFinal, wStep):
            fileName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, densityEvolution=True, r0=r0, timeEvolAngMom=angMom, timeEvolEps=eps, timeEvolOmega=round(w,2))
            if args.bulkprobe == 0:
                plt.ylabel(r'$\Delta\rho_{edge}$')
                t, edgeDensity = gm.LoadFileTwo(fileName + '_edge')
                plt.scatter(t, edgeDensity, marker='o', s=1.5, facecolors=colors[c], label=f'$\omega={{{round(w,2)}}}$')
            else:
                plt.ylabel(r'$\Delta\rho_{bulk}$')
                t, bulkDensity = gm.LoadFileTwo(fileName + '_bulk')
                plt.scatter(t, bulkDensity, marker='o', s=1.5, facecolors=colors[c], label=f'$\omega={{{round(w,2)}}}$')
            plt.legend()
            c = c + 1
        plotName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, densityEvolution=True, r0=r0)
        plt.savefig(plotName+'_multifreq.pdf')
        plt.close()
        
if args.densityhisto == 1:

    tDensity = args.tdensity
    wData = []
    rhoEdgeData = []
    rhoBulkData = []
    
    if bulkProbeFlag == False:
        for w in np.arange(wInit, wFinal, wStep):
            fileName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, densityEvolution=True, r0=r0, timeEvolAngMom=angMom, timeEvolEps=eps, timeEvolOmega=round(w,2)) + '_edge'
            t, edgeDensity = gm.LoadFileTwo(fileName)
            
            tIndex = np.where(t == tDensity)[0][0]
            
            wData.append(w)
            rhoEdgeData.append(edgeDensity[tIndex])
        
        plt.xlabel(r'$\omega$')
        plt.xlim(left=0,right=wFinal)
        plt.ylabel(r'$\Delta\rho_{edge}$')
        #plt.yticks([0.0,round(np.max(rhoEdgeData),2)])
        plt.text(0.03, 0.8, f'$t^*={{{tDensity}}}\hbar / J$', transform=plt.gca().transAxes, fontsize=25)
        plt.text(0.03, 0.9, f'$l={{{angMom}}}$', transform=plt.gca().transAxes, fontsize=25)
            
        plt.bar(wData, rhoEdgeData, width=wStep/2., color='skyblue', edgecolor='black', alpha=0.7)
        plotName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, densityEvolution=True, r0=r0, timeEvolAngMom=angMom, timeEvolEps=eps) + f'_edge_histo_t_{tDensity}'
        plt.savefig(plotName+'.pdf')
        
        if args.savemaxdensity == 1:
            # Here it saves the maximum of density (EDGE)
            maxEdgeDensity = np.max(rhoEdgeData)
            fileName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, densityEvolution=True, r0=r0) + '_edge_maxdensity'
            maxIndices, _ = sp.signal.find_peaks(rhoEdgeData, height=maxEdgeDensity/2.)
            maxOmegaList = [wData[i] for i in maxIndices]
                
            for wMax in maxOmegaList:
                gm.SaveTwoColFile(fileName, angMom, wMax)
        
    else:
        for w in np.arange(wInit, wFinal, wStep):
            fileName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, densityEvolution=True, r0=r0, timeEvolAngMom=angMom, timeEvolEps=eps, timeEvolOmega=round(w,2)) + '_bulk'
            t, bulkDensity = gm.LoadFileTwo(fileName)
            
            tIndex = np.where(t == tDensity)[0][0]
            
            wData.append(w)
            rhoBulkData.append(bulkDensity[tIndex])
        
        plt.xlabel(r'$\omega$')
        plt.xlim(left=0,right=wFinal)
        plt.ylabel(r'$\Delta\rho_{bulk}$')
        plt.yticks([0.0,round(np.max(rhoBulkData),2)])
        plt.text(0.05, 0.05, f'$t^*={{{tDensity}}}$', transform=plt.gca().transAxes, fontsize=12)
        plt.text(0.05, 0.1, f'$l={{{angMom}}}$', transform=plt.gca().transAxes, fontsize=12)
            
        plt.bar(wData, rhoBulkData, width=wStep/2., color='skyblue', edgecolor='black', alpha=0.7)
        plotName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, densityEvolution=True, r0=r0, timeEvolAngMom=angMom, timeEvolEps=eps) + f'_bulk_histo_t_{tDensity}'
        plt.savefig(plotName+'.pdf')
        
        if args.savemaxdensity == 1:
            # Here it saves the maximum of density (BULK)
            maxBulkDensity = np.max(rhoBulkData)
            fileName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, densityEvolution=True, r0=r0) + '_bulk_maxdensity'
            maxIndices, _ = sp.signal.find_peaks(rhoBulkData, height=maxBulkDensity/2.)
            maxOmegaList = [wData[i] for i in maxIndices]
                
            for wMax in maxOmegaList:
                gm.SaveTwoColFile(fileName, angMom, wMax)
    
if protocolResults == True:
    fig, ax = plt.subplots()
    cmap = mpl.colormaps['ocean_r']
    sm = mpl.cm.ScalarMappable(cmap=cmap, norm=plt.Normalize(vmin=0.0, vmax=0.7))
    #norm = mpl.colors.Normalize(vmin=0.0, vmax=1.0)
    
    # l < 0 region
    fileName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, absSpectrum=True, r0=args.r0)
    energy, l, matElem = gm.LoadFileThree(fileName+'_neg')
    
    matElem[matElem < 1e-5] = np.NaN
    
    sm.set_array(matElem)
    colors = sm.to_rgba(matElem)
    
    for i in np.arange(0,len(energy)):
        rect = patches.Rectangle((l[i] - 0.45, energy[i]), width=0.9, height=0.003, color=colors[i])
        ax.set_facecolor(cmap(0))
        ax.add_patch(rect)
        
    # l > 0 region
    fileName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, absSpectrum=True, r0=args.r0)
    energy, l, matElem = gm.LoadFileThree(fileName+'_pos')
    
    matElem[matElem < 1e-5] = np.NaN
    
    sm.set_array(matElem)
    colors = sm.to_rgba(matElem)
    
    for i in np.arange(0,len(energy)):
        rect = patches.Rectangle((l[i] - 0.45, energy[i]), width=0.9, height=0.003, color=colors[i])
        ax.set_facecolor(cmap(0))
        ax.add_patch(rect)

    ax.set_xlim(-max(l) - 0.5, max(l) + 0.5)
    if args.sety == 0:
        ax.set_ylim(0.0, max(energy) + 0.1)
    else:
        ax.set_ylim(0.0, args.sety)
    
    plt.xticks(np.arange(-max(l),max(l)+1,1))
    
    cbar = plt.colorbar(sm)
    cbar.set_label(r'$|I_n|^2$')
    plt.xlabel(r'$l$')
    plt.ylabel(r'$\omega_n$')
    
    if args.bulkprobe == 1:
        resonanceFileName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, densityEvolution=True, r0=r0) + '_bulk_maxdensity'
    else:
        resonanceFileName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, densityEvolution=True, r0=r0) + '_edge_maxdensity'
    angMomRes, wMax = gm.LoadFileTwo(resonanceFileName)
    plt.scatter(angMomRes, wMax, marker='o', s=7.0, facecolors='r', label=r'$\omega_{res}$')
    #plt.legend(loc='center right', borderpad=0.5)
    
    plotFileName = gm.GenFilename(hardcore, L, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, absSpectrum=True, r0=args.r0)
    plt.savefig(plotFileName+'_resonances.pdf')
        
if args.gammasplit == 1:
    splitting = []
    gammaData = []
    colors = ['green', 'orange']
    c = 0
    for l in [-2]:
        for g in np.arange(2, gammaFinal, 0.1):
            if (l < 0):
                fileName = gm.GenFilename(hardcore, L, J, U, trapConf, round(g,2), 0, U3=U3, alpha=FluxDensity, N=N, absSpectrum=True, r0=args.r0) + '_neg'
            elif (l > 0):
                fileName = gm.GenFilename(hardcore, L, J, U, trapConf, round(g,2), 0, U3=U3, alpha=FluxDensity, N=N, absSpectrum=True, r0=args.r0) + '_pos'
            energy, angularMomentum, amplitude = gm.LoadFileThree(fileName)
            energy = energy[angularMomentum == l]
            amplitude = amplitude[angularMomentum == l]
            
            # Now it finds the two maximum amplitudes for which we compute the splitting
            firstMaxAmplitude = np.max(amplitude)
            firstMaxAmplitudeIdx = np.where(amplitude == firstMaxAmplitude)[0][0]
            firstMaxEnergy = energy[firstMaxAmplitudeIdx]
            
            amplitude = np.delete(amplitude, firstMaxAmplitudeIdx)
            energy = np.delete(energy, firstMaxAmplitudeIdx)
            
            secondMaxAmplitude = np.max(amplitude)
            secondMaxAmplitudeIdx = np.where(amplitude == secondMaxAmplitude)[0][0]
            secondMaxEnergy = energy[secondMaxAmplitudeIdx]
            
            gammaData.append(round(g,2))
            splitting.append(np.abs(firstMaxEnergy - secondMaxEnergy))
        
        plt.xlabel(r'$\gamma$')
        plt.xticks([2,2.5,3,3.5,3.9])
        plt.ylabel(r'$\Delta_{l=-2}$')
        plt.yticks([0,0.13])
        plt.scatter(gammaData, splitting, marker='o', s=1.5, facecolors=colors[c], label=f'$l={{{l}}}$')
        plt.plot(gammaData, splitting, color=colors[c], linewidth=0.7)
        #plt.legend()
        c = c + 1
        gammaData = []
        splitting = []
        
    ax = plt.gca()
    ax.set_ylim(bottom=0)
    plt.savefig(fileName+'_gammasplit.pdf')
    
if args.sizesplit == 1:
    splitting = []
    sizeData = []
    colors = ['green', 'orange']
    c = 0
    for l in [-2]:
        for systemSize in np.arange(L, 5, -1):
            if (l < 0):
                fileName = gm.GenFilename(hardcore, systemSize, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, absSpectrum=True, r0=args.r0) + '_neg'
            elif (l > 0):
                fileName = gm.GenFilename(hardcore, systemSize, J, U, trapConf, gamma, 0, U3=U3, alpha=FluxDensity, N=N, absSpectrum=True, r0=args.r0) + '_pos'

            energy, angularMomentum, amplitude = gm.LoadFileThree(fileName)
            energy = energy[angularMomentum == l]
            amplitude = amplitude[angularMomentum == l]
            
            # Now it finds the two maximum amplitudes for which we compute the splitting
            firstMaxAmplitude = np.max(amplitude)
            firstMaxAmplitudeIdx = np.where(amplitude == firstMaxAmplitude)[0][0]
            firstMaxEnergy = energy[firstMaxAmplitudeIdx]
            
            amplitude = np.delete(amplitude, firstMaxAmplitudeIdx)
            energy = np.delete(energy, firstMaxAmplitudeIdx)
            
            secondMaxAmplitude = np.max(amplitude)
            secondMaxAmplitudeIdx = np.where(amplitude == secondMaxAmplitude)[0][0]
            secondMaxEnergy = energy[secondMaxAmplitudeIdx]
            
            sizeData.append(int(systemSize))
            splitting.append(np.abs(firstMaxEnergy - secondMaxEnergy))
            
        plt.xlabel(r'$L_{x,y}$')
        plt.xticks(np.arange(L,5,-1))
        plt.ylabel(r'$\Delta_{l=-2}$')
        plt.scatter(sizeData, splitting, marker='o', s=1.5, facecolors=colors[c], label=f'$l={{{l}}}$')
        plt.plot(sizeData, splitting, color=colors[c], linewidth=0.7)
        #plt.legend()
        c = c + 1
        sizeData = []
        splitting = []
        
    ax = plt.gca()
    ax.invert_xaxis()
    ax.set_ylim(bottom=0)
    plt.savefig(fileName+'_sizesplit.pdf')
